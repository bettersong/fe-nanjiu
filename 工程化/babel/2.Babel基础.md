## babel发展史

Babel的前身是从6to5这个库发展而来，6to5的作者是Facebook的澳大利亚工程师Sebastian McKenzie在2014年发布的；从它的名字我们也能看出来，主要的功能就是将ES6转成ES5。

在2015年1月份，6to5和Esnext的团队决定一起开发6to5，并且改名为Babel，解析引擎改名为Babylon。

- 2015-02-15，6to5重命名为babel；
- 2015-03-31，babel 5.0发布；
- 2015-10-30，babel 6.0发布；
- 2018-08-27，babel 7.0发布；

## babel的编译流程

![1-babel-ast](/Users/songyao/Desktop/songyao/fe-nanjiu/images/22-12/1-babel-ast.png)

### parse阶段

这个阶段主要是将源码编译成AST抽象语法树，它是通过`@babel/parser`来进行词法分析与语法分析后组装成AST。

这个过程又分为词法分析、语法分析

#### 词法分析

这个过程简单理解就是将代码字符串拆分成一个个不能够再细分的`token`

> code -> token

#### 语法分析

这个过程就是将词法分析生成的`token`进行递归组装，生成AST

> token -> AST

### transform阶段

这个阶段主要是对AST进行改造（转换），通过`@babel/traverse`对AST进行遍历，并调用 `visitor` 函数修改 AST，修改 AST 自然涉及到 AST 的判断、创建、修改等，这时候就需要使用 `@babel/types` ，当需要批量创建 AST 的时候可以使用 @babel/template 来简化 AST 创建逻辑。

### generator阶段

这个阶段主要是将改造后的AST反编译成目标代码字符串，同时可生成`sourcemap`，主要依赖`@babel/generator`

## 主要API

这里我们来学习一下`Babel`的几个主要的package，从文档上来看Babel的工具包主要有以下这些：

<img src="/Users/songyao/Desktop/songyao/fe-nanjiu/images/2023/01/babel-package.png" alt="babel-package" style="zoom:50%;" />

### @babel/parser

> 从名字上很明显这个模块是用来做编译的，它支持对JS、JSX、Flow、TypeScript的编译。它会根据`Babel AST`格式来将代码生成AST，需要注意的是，它默认只支持对JS的编译，对于JSX、Flow、TypeScript等需要指定对应的插件。

它主要提供了两个API，两者都是用来生成AST语法树的，`parse()`将提供`code`的作为整个 ECMAScript 程序进行解析，同时 `parseExpression()`尝试在考虑性能的情况下解析单个表达式。

#### parse

> babelParser.parse(code, [options])

#### parseExpression

> babelParser.parseExpression(code, [options])

#### 参数options

主要参数有以下这些，其余可查看官方文档

- **plugins**：包含要启用的插件的数组。
- **sourceType**：指示应在其中解析代码的模式。可以是`"script"`、`"module"`或之一`"unambiguous"`。默认为`"script"`. `"unambiguous"`将使@babel/parser 尝试根据 ES6或语句的存在进行*猜测。*考虑带有 ES6和s 的文件，否则为.`import` `export` `import` `export` `"module"` `"script"`
- **sourceFilename**：将输出 AST 节点与其源文件名相关联。从多个输入文件的 AST 生成代码和源映射时很有用。
- **startColumn**：默认情况下，解析后的代码被视为从第 1 行第 0 列开始。可以提供一个列号作为开始。用于与其他源工具集成。
- **startLine**：默认情况下，解析后的代码被视为从第 1 行第 0 列开始。可以提供一个行号作为开始。用于与其他源工具集成。
- **strictMode**：默认情况下，仅当 `"use strict";`指令存在或解析的文件是 ECMAScript 模块时，ECMAScript 代码才被解析为严格模式。将此选项设置`true`为始终以严格模式解析文件。
- **ranges**`range` ：向每个节点添加一个属性：`[node.start, node.end]`
- **tokens**：将所有已解析的令牌添加到节点`tokens`上的属性`File`

```js
const parser = require("@babel/parser")

const code = `
    const name = '前端南玖'
`
const res = parser.parse(code, {
    sourceType: "unambiguous"
})
```

### @babel/traverse

> 该模块主要是用来遍历AST语法树，它维护了整棵树的状态，并且负责替换、移除和添加节点。

#### traverse

> traverse(ast, options)

```js
traverse(ast, {
  enter(path) {
    if (
      path.node.type === "Identifier" &&
      path.node.name === "n"
    ) {
      path.node.name = "x";
    }
  }
});
```

#### 遍历

当我们谈及“进入”一个节点，实际上是说我们在**访问**它们， 之所以使用这样的术语是因为有一个[**访问者模式（visitor）**](https://en.wikipedia.org/wiki/Visitor_pattern)的概念。

访问者是一个用于 AST 遍历的跨语言的模式。 简单的说它们就是一个对象，定义了用于在一个树状结构中获取具体节点的方法。 



### @babel/core

### @babel/generator

### @babel/code-frame

### 

### @babel/types

