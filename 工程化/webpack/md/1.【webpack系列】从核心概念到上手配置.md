## 核心概念

### 输入输出

#### entry

> webpack的构建入口，**入口起点(entry point)** 指示 webpack 应该使用哪个模块，来作为构建其内部 [依赖图(dependency graph)](https://webpack.docschina.org/concepts/dependency-graph/) 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。

```js
// 单入口
module.exports = {
  entry: './src/main.js'
}

// 多入口
module.exports = {
  entry: {
    a: './src/a.js',
    b: './src/b.js'
  }
}
```

#### output

> **output** 属性告诉 webpack 在哪里输出它所创建的 *bundle*，以及如何命名这些文件。主要输出文件的默认值是 `./dist/main.js`，其他生成文件默认放置在 `./dist` 文件夹中。

```js
// 单入口
module.exports = {
  entry: './src/main.js',
  output: {
    filename: 'bundle.js',   
    path: path.resolve(__dirname, 'dist'),
  }
}
// 多入口
module.exports = {
  entry: {
    a: './src/a.js',
    b: './src/b.js'
  },
  output: {
    filename: '[name].[hash:6].js', // 通过占位符确保文件名唯一，考虑缓存问题，还可以为文件名加上hash
    path: __dirname + '/dist',
    publicPath: '/',    // 生产环境一般是CDN地址，开发环境配置为/或不配置
  }
}
```

### 模块处理

#### loader

> webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。**loader** 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 [模块](https://webpack.docschina.org/concepts/modules)，以供应用程序使用，以及被添加到依赖图中。

比如：配置webpack为css文件应用`css-loader`

```js
module.exports = {
  module: {
    rules: [
      {test: /\.css$/, use: 'css-loader'}
    ]
  }
}
```

[`module.rules`](https://webpack.docschina.org/configuration/module/#modulerules) 允许你在 webpack 配置中指定多个 loader。 这种方式是展示 loader 的一种简明方式，并且有助于使代码变得简洁和易于维护。

#### plugin

> **插件** 是 webpack 的 [支柱](https://github.com/webpack/tapable) 功能。Webpack 自身也是构建于你在 webpack 配置中用到的 **相同的插件系统** 之上！
>
> 插件目的在于解决 [loader](https://webpack.docschina.org/concepts/loaders) 无法实现的**其他事**。Webpack 提供很多开箱即用的 [插件](https://webpack.docschina.org/plugins/)。

比如：为编译过程添加进度报告插件

```js
const Webpack = require('webpack')
module.exports = {
  plugins: [new Webpack.ProgressPlugin()]
}
```

#### resolve

> 用于配置模块路径解析规则，可用于帮助 Webpack 更精确、高效地找到指定模块

比如配置别名：

创建 `import` 或 `require` 的别名，来确保模块引入变得更简单。例如，一些位于 `src/` 文件夹下的常用模块：

```js
module.exports = {
  resolve: {
    alias: {
      node_modules: path.resolve(__dirname, './node_modules'),
      '@': path.resolve(__dirname, './src'),
      api: path.resolve(__dirname, './src/api'),
      components: path.join(__dirname, './src/components'),
    }
  }
}
```

#### module

> 这些选项决定了如何处理项目中的[不同类型的模块](https://webpack.docschina.org/concepts/modules)。

比如我们常见的loader就是在`module.rules`内配置的。

```js
module.exports = {
  module: {
    rules: [
      {test: /\.css$/, use: 'css-loader'}
    ]
  }
}
```

#### externals

> 用于声明外部资源，Webpack 会直接忽略这部分资源，跳过这些资源的解析、打包操作

比如**防止**将某些 `import` 的包(package)**打包**到 bundle 中，而是在运行时(runtime)再去从外部获取这些*扩展依赖(external dependencies)*。

比如：从CDN引入Vue

```html
<!-- index.html -->
<script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.3/vue.min.js"></script>
```

```js
// webpack.config.js
module.exports = {
  externals: {
    vue: 'vue'
  }
}
```

### 后处理

#### optimization

> 用于控制如何优化产物包体积，内置 Dead Code Elimination、Scope Hoisting、代码混淆、代码压缩等功能
>
> 从 webpack 4 开始，会根据你选择的 [`mode`](https://webpack.docschina.org/concepts/mode/) 来执行不同的优化， 不过所有的优化还是可以手动配置和重写。

```js
module.exports = {
  //...
  optimization: {
    chunkIds: 'named',
  },
};
```

#### target

> 用于配置编译产物的目标运行环境，支持 web、node、electron 等值，不同值最终产物会有所差异

比如：target设置为node，webpack将在node环境下进行编译

```js
module.exports = {
  target: 'node'
}
```

#### mode

> 提供 `mode` 配置选项，告知 webpack 使用相应模式的内置优化。

```js
string = 'production': 'none' | 'development' | 'production'
```

```js
module.exports = {
  mode: 'development',
};
```

或者从cli` --mode` 参数进行传递

```shell
webpack --mode development
```

### 开发效率

#### watch

> 启用 Watch 模式。这意味着在初始构建之后，webpack 将继续监听任何已解析文件的更改。

```js
module.exports = {
  watch: true
}
```

**⚠️注意：`webpack-dev-server`和`webpack-dev-middleware`默认是开启watch模式的**

