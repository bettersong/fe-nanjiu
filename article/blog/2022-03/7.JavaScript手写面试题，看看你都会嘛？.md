

## 防抖

### 原理

> 事件高频触发后，n秒内函数只会执行一次，若n秒内事件再次触发，则重新计时，总之就是要等触发完事件 n 秒内不再触发事件，函数才执行

### 代码实现

```js
function debounce(callback, wait) {
    let timer
    return function (...args) {
        clearTimeout(timer)
        timer = setTimeout(() => {
            callback.call(this,args)
        },wait)
    }
}

// 使用
document.body.addEventListener('mousemove',debounce((e)=>{
  console.log(this,e,'mousemove-debounce')
},1000))
```

## 节流

### 原理

> 如果事件持续触发，在指定时间内，只执行一次事件

### 代码实现

**时间戳方式**

```js
// 时间戳方式
/**
使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，
如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。
*/
function throttle(callback, wait) {
    let start = 0
    return function(...args) {
        const now = +new Date()
        if(now-start >= wait ) {
            callback.call(this,args)
            start = now
        }
        
    }
}
//使用
const cb = throttle(function(e){
    console.log(this)
},1000)
document.body.addEventListener('mousemove',()=>{
    cb.call({name:'南玖'})
},1000)
// {name: '南玖'}
```

**定时器方式**

```js
// 定时器方式
/**
 * 
 * 当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，
 * 直到定时器执行，然后执行函数，清空定时器。
 */
function throttle(callback, wait) {
    let timer
    return function(...args) {
        if(!timer) {
            timer = setTimeout(()=>{
                timer = null
                callback.call(this,args)
            },wait)
        }
    }
}

const cb = throttle(function(e){
    console.log(this)
},1000)
document.body.addEventListener('mousemove',()=>{
    cb.call({name:'南玖'})
},1000)
// {name: '南玖'}
```

## 模拟new运算符

> **`new` 运算符**创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。

### 原理

- 新建一个空对象
- 链接到原型
- 绑定this
- 返回该对象

### 代码实现

```js
function myNew() {
// 1.新建一个空对象
let obj = {}
// 2.获得构造函数
let con = [].shift.call(arguments)
// 3.链接原型,实例的 __proto__ 属性指向构造函数的 prototype
obj.__proto__ = con.prototype
// 4.绑定this，执行构造函数
let res = con.apply(obj, arguments)
// 5.返回新对象
return typeof res === 'object' ? res : obj
}

function Person(name) {
    this.name = name
}
let person = myNew(Person,'nanjiu')
console.log(person) //{name: "nanjiu"}
console.log(typeof person === 'object') //true
console.log(person instanceof Person) // true
```

## 模拟instanceof

`instanceof` 用于检测构造函数的`prototype`是否在实例的原型链上，需要注意的是instanceof只能用来检测引用数据类型，对于基本数据检测都会返回false

### 原理

通过循环检测实例的`__proto__`属性是否与构造函数的`prototype`属性相等

### 代码实现

```js
/**
 * instanceof 用于检测构造函数的prototype是否在实例的原型链上
 */
function myInstanceof(left, right) {
    // 先排除基本数据类型
    if(typeof left !== 'object' || left === null) return false
    let proto = left.__proto__
    while(proto) {
        if(proto === right.prototype) return true
        proto = proto.__proto__
    }
    return false
}

function Person() {}
let person = new Person()
console.log(myInstanceof(person,Person)) // true
```

##模拟Function.prototype.apply()

> **`apply()`** 方法调用一个具有给定`this`值的函数，以及以一个数组（或类数组对象）的形式提供的参数。

```js
Function.prototype.myApply = function(context) {
    var context = context || window // 获取需要绑定的this
    context.fn = this // 获取需要改变this的函数
    const arg = arguments[1] // 获取传递给函数的参数

    if(!(arg instanceof Array)) {
        throw Error('参数需要是一个数组')
    }
    const res = context.fn(...arg) // 执行函数
    delete context.fn // 删除该方法
    return res // 返回函数返回值
}
function say(a,b,c) {
    console.log(this.name,a,b,c)
}
say.myApply({name:'nanjiu'},[1,2,3]) //nanjiu 1 2 3
say.apply({name:'nanjiu'},[1,2,3]) //nanjiu 1 2 3
```

## 模拟Function.prototype.call()

> `call()` 方法使用一个指定的 `this` 值和单独给出的一个或多个参数来调用一个函数。

```js
Function.prototype.myCall = function(context) {
    var context = context || window // 获取需要改变的this
    context.fn = this // 获取需要改变this的函数
    const args = [...arguments].slice(1) // 获取参数列表
    const res = context.fn(...args) // 将参数传给函数并执行
    delete context.fn // 删除该方法
    return res // 返回函数返回值
}

function say(a,b,c) {
    console.log(this.name,a,b,c)
}
say.myCall({name:'nanjiu'},1,2,3) //nanjiu 1 2 3
say.call({name:'nanjiu'},1,2,3) //nanjiu 1 2 3
```

## 模拟Function.prototype.bind()

> `bind()` 方法创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。

```js
Function.prototype.myBind = function(context) {
    var context = context || window //获取需要改变的this
    context.fn = this  // 获取需要改变this的函数

    //获取函数参数
    const args = [...arguments].slice(1)
    // 与apply，call不同的是这里需要返回一个函数
    return () => {
        return context.fn.apply(context,[...args])
    }

}

function say(a,b,c) {
    console.log(this.name,a,b,c)
}
say.bind({name: 'nanjiu'},1,2,3)() //nanjiu 1 2 3
say.myBind({name: 'nanjiu'},1,2,3)() //nanjiu 1 2 3
```

## 模拟Array.prototype.forEach()

> `forEach()` 方法对数组的每个元素执行一次给定的函数，无返回值。

### 语法

```js
arr.forEach(callback(currentValue [, index [, array]])[, thisArg])
```

### 参数

- `callback`

  为数组中每个元素执行的函数，该函数接收一至三个参数：`currentValue`数组中正在处理的当前元素。`index` 可选数组中正在处理的当前元素的索引。`array` 可选`forEach()` 方法正在操作的数组。

- `thisArg` 可选

  可选参数。当执行回调函数 `callback` 时，用作 `this` 的值。

### 代码实现

```js
Array.prototype.myForEach = function(callback, context) {
    const arr = this // 获取调用的数组
    const len = arr.length || 0

    let index = 0  // 数组下标
    while(index < len) {
        callback.call(context ,arr[index], index)
        index++
    }
}

let arr = [1,2,3]
arr.forEach((item,index) => {
    console.log(`key: ${index} - item: ${item}`)
})
console.log('----------')
arr.myForEach((item,index) => {
    console.log(`key: ${index} - item: ${item}`)
})
/**
 * key: 0 - item: 1
key: 1 - item: 2
key: 2 - item: 3
----------
key: 0 - item: 1
key: 1 - item: 2
key: 2 - item: 3
 */
```

## 模拟Array.prototype.map()

> `map()` 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。

### 语法

```js
var new_array = arr.map(function callback(currentValue[, index[, array]]) {
 // Return element for new_array 
}[, thisArg])
```

### 参数

callback

生成新数组元素的函数，使用三个参数：

- `currentValue`

  数组中正在处理的当前元素。

- `index`可选

  数组中正在处理的当前元素的索引。

- `array`可选

  `map` 方法调用的数组。

`thisArg`可选

执行 `callback` 函数时值被用作`this`。

### 代码实现

```js
/**
 * map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。
 */
Array.prototype.myMap = function(callback, context) {
    const arr = this,res = []
    const len = arr.length || 0
    let index = 0
    while(index < len) {
        res.push(callback.call(context, arr[index], index))
        index ++
    }
    return res  // 与forEach不同的是map有返回值
}
const arr = [1,2,3]
let res1 = arr.map((item,index) => {
    return `k:${index}-v:${item}`
})
let res2 = arr.myMap((item,index) => {
    return `k:${index}-v:${item}`
})
console.log(res1) // [ 'k:0-v:1', 'k:1-v:2', 'k:2-v:3' ]
console.log(res2) // [ 'k:0-v:1', 'k:1-v:2', 'k:2-v:3' ]
```

## 模拟Array.prototype.filter()

> `filter()` 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 

### 语法

```js
var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])
```

### 参数

callback

用来测试数组的每个元素的函数。返回 `true` 表示该元素通过测试，保留该元素，`false` 则不保留。它接受以下三个参数：

- `element`

  数组中当前正在处理的元素。

- `index`可选

  正在处理的元素在数组中的索引。

- `array`可选

  调用了 `filter` 的数组本身。

`thisArg`可选

执行 `callback` 时，用于 `this` 的值。

### 代码实现

```js
/**
 * `filter()` 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 
 */

Array.prototype.myFilter = function(callback, context) {
    const arr = this,res = []
    const len = arr.length
    let index = 0
    while(index < len) {
        if(callback.call(context,arr[index],index)) {
            res.push(arr[index])
        }
        index ++   
    }
    return res
}

const arr = [1,2,3]
let res1 = arr.filter((item,index) => {
    return item<3
})
let res2 = arr.myFilter((item,index) => {
    return item<3
})

console.log(res1) // [ 1, 2 ]
console.log(res2) // [ 1, 2 ]
```

## 函数柯里化

> 柯里化，英语：Currying(果然是满满的英译中的既视感)，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。

先来理解一下什么是函数柯里化，上面文绉绉的内容可能不是那么容易理解，我们还是直接上代码来理解吧

```js
// 假如有这样一个函数
function add (a,b,c) {
    console.log(a+b+c)
}
add(1,2,3) //6
/**
 * 我们希望可以通过add(1,2)(3)或add(1)(2)(3)或add(1)(2,3)这样调用也能够得倒正确的计算结果
 这就是函数柯里化的简单应用
 */
```

### 代码实现

```js
function curry(fn, curArgs) {
    const len = fn.length  // 需要柯里化函数的参数个数
    curArgs = curArgs || []

    return function() {
        let args = [].slice.call(arguments) // 获取参数
        args = curArgs.concat(args) //拼接参数
        // 基本思想就是当拼接完的参数个数与原函数参数个数相等才执行这个函数，否则就递归拼接参数
        if(args.length < len) {
            return curry(fn, args)
        }else{
            return fn.apply(this, args)
        }
    }
}

let fn = curry(function(a,b,c){
    console.log([a,b,c])
})
fn(1,2,3) // [ 1, 2, 3 ]
fn(1,2)(3) // [ 1, 2, 3 ]
fn(1)(2,3) // [ 1, 2, 3 ]
fn(1)(2)(3) // [ 1, 2, 3 ]
```

## 类数组转数组

> 类数组是具有**length**属性，但不具有数组原型上的方法。常见的类数组有**arguments**、DOM操作方法返回的结果。

```js
function translateArray() {
    //方法一：Array.from
    const res1 = Array.from(arguments)
    console.log(res1 instanceof Array, res1) // true [ 1, 2, 3 ]

    // 方法二：Array.prototype.slice.call
    const res2 = Array.prototype.slice.call(arguments)
    console.log(res2 instanceof Array, res2) // true [ 1, 2, 3 ]

    // 方法三：concate
    const res3 = [].concat.apply([],arguments)
    console.log(res3 instanceof Array, res3) // true [ 1, 2, 3 ]

    // 方法四：扩展运算符
    const res4 = [...arguments]
    console.log(res4 instanceof Array, res4) // true [ 1, 2, 3 ]
}

translateArray(1,2,3)

```

## 实现深拷贝



## 继承的实现



## 实现AJAX



## 实现一个简易版模版引擎



## 多维数组扁平化



## setTimeout 模拟 setInterval



##setInterval 模拟 setTimeout



## 数组去重的多种实现方式



## 解析URL参数



## sleep





## 斐波那契数列



## 列表转数结构



## 发布订阅



## 实现一个Promise









