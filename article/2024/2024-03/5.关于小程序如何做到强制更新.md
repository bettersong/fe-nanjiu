## 前言

在小程序的日常迭代中，有一些场景我们可能需要在小程序发布后，用户能够马上感知并更新，比如上线新活动、修复高危漏洞等，如果用户因为各种原因未能及时更新小程序，这就可能导致一些功能无法正常使用或者存在安全隐患，因此，实现小程序的强制更新功能就显得尤为重要。本文将探讨小程序如何做到强制更新，以确保用户始终使用最新、最安全的小程序版本。

## 小程序的运行机制

在这之前，我们得先来了解一下小程序的生命周期，从启动到销毁它都是如何进行的

### 生命周期

<img src="/Users/songyao/Desktop/songyao/fe-nanjiu/article/2024/2024-03/images/wx-1.png" alt="image-20240314145458296" style="zoom:50%;" />

### 小程序的启动

广义的小程序启动可以分为两种情况，一种是**冷启动**，一种是**热启动**。

从小程序生命周期的角度来看，我们一般讲的「**启动**」专指冷启动，热启动一般被称为后台切前台。

- 冷启动：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动。
- 热启动：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程就是热启动。

### 前台与后台

- 前台：小程序的「**前台**」状态一般指的是小程序处于打开状态，页面正在展示给用户
- 后台：当用户关闭小程序时小程序并没有真正被关闭，而是进入了「**后台**」状态

切后台的方式包括但不限于以下几种：

- 点击右上角胶囊按钮离开小程序
- iOS 从屏幕左侧右滑离开小程序
- 安卓点击返回键离开小程序
- 小程序前台运行时直接把微信切后台（手势或 Home 键）
- 小程序前台运行时直接锁屏

### 挂起

小程序进入「后台」状态一段时间后（目前是 5 秒），微信会停止小程序 JS 线程的执行，小程序进入「**挂起**」状态。此时小程序的内存状态会被保留，但开发者代码执行会停止，事件和接口回调会在小程序再次进入「前台」时触发。

当开发者使用了**后台音乐播放**、**后台地理位置**等能力时，小程序可以在**「后台」**持续运行，不会进入到**「挂起」**状态

### 销毁

当小程序进入后台或被挂起时，它并不会一直保留在后台，当满足以下两点时，小程序会被销毁

- 当小程序进入后台并被「挂起」后，如果很长时间（目前是 30 分钟）都未再次进入前台，小程序会被销毁。
- 当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。

## 小程序的更新机制

小程序默认的更新机制可以分为两类：**启动时同步更新**、**启动时异步更新**

### 启动时同步更新

在以下情况下，小程序启动时会同步更新代码包。同步更新会阻塞小程序的启动流程，影响小程序的启动耗时。

- 定期检查发现版本更新，微信运行时定时检查下载更新，如果有更新，下次小程序启动时会同步进行更新，更新到最新版本后再打开小程序
-  用户长时间未使用小程序，会强制同步更新

### 启动时异步更新

- 即使启动前未发现更新，小程序每次冷启动时，都会异步检查是否有更新版本。如果发现有新版本，将会异步下载新版本的代码包。但当次启动仍会使用客户端本地的旧版本代码，即新版本的小程序需要等下一次冷启动才会使用

### 强制更新

在启动时异步更新的情况下，如果开发者希望立刻进行版本更新，可以使用 `wx.getUpdateManager`API 进行处理，该API会返回一个`UpdateManager`实例

`UpdateManager` 对象为小程序提供了四种关键的方法，用于管理和监控小程序的更新过程。

- `UpdateManager.applyUpdate()`：在小程序新版本已经下载完成的情况下（即接收到 `onUpdateReady` 回调后），此方法用于强制小程序重启并启用新版本。

- `UpdateManager.onCheckForUpdate(function callback)`：此方法用于监听向微信后台发起的更新检查结果事件。微信小程序在冷启动时会自动进行更新检查，开发者无需主动触发。

- `UpdateManager.onUpdateReady(function callback)`：此方法用于监听小程序的新版本更新就绪事件。一旦新版本可用，客户端会自动触发下载过程（无需开发者额外操作），并在下载成功后调用此回调函数。

- `UpdateManager.onUpdateFailed(function callback)`：此方法用于监听小程序更新失败的事件。当小程序有新版本且客户端尝试自动下载更新时（同样无需开发者干预），如果因网络问题或其他原因导致下载失败，将会触发此回调函数。

根据以上API，我们就能够在小程序法版后，通知用户进行强制更新

```js
if (taro.canIUse('getUpdateManager')) {
      const updateManager = taro.getUpdateManager();
      updateManager.onCheckForUpdate(function (res) {
        console.log('onCheckForUpdate====', res);
        if (res.hasUpdate) {
          // 小程序已更新
          updateManager.onUpdateReady(function () {
            taro.showModal({
              title: '更新提示',
              showCancel: false,
              confirmText: '立即重启',
              content: '新版本已经上线，是否重启小程序以应用新版本？',
              success: function (res) {
                if (res.confirm) {
                  // 调用 applyUpdate 应用新版本并重启
                  updateManager.applyUpdate();
                }
              }
            });
          });
          // 更新失败
          updateManager.onUpdateFailed(function () {
            taro.showModal({
              title: '更新失败',
              content: '新版本下载失败，请删除当前小程序后重新打开。',
            });
          });
        }
      });
    } else {
      // 版本过低
      taro.showModal({
        title: '提示',
        content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。',
      });
    }
```

<img src="/Users/songyao/Desktop/songyao/fe-nanjiu/article/2024/2024-03/images/wx-2.gif" alt="wx-2" style="zoom:50%;" />

因为小程序的开发版和体验版没有版本的概念，所以无法在开发版和体验版上测试更版本更新情况，但可以通过微信开发者工具 => 添加编译模式 => 编译设置 => 下次编译时模拟更新来进行调试

<img src="/Users/songyao/Library/Application Support/typora-user-images/image-20240314161644758.png" alt="image-20240314161644758" style="zoom:33%;" />